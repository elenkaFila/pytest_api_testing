{"uid":"10c5f68a1718af15","name":"test_get_bookings_with_filter_name","fullName":"tests.test_get_bookings#test_get_bookings_with_filter_name","historyId":"9d33b44b6503964b07ca9093e56ba7a5","time":{"start":1748888445470,"stop":1748888450512,"duration":5042},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)","statusTrace":"self = <Response [503]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n\n../local/lib/python3.10/site-packages/requests/models.py:974: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../local/lib/python3.10/json/__init__.py:346: in loads\n    return _default_decoder.decode(s)\n../local/lib/python3.10/json/decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7f0884d15c60>\ns = '<!DOCTYPE html>\\n<html>\\n  <head>\\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n    <met...  <body>\\n    <iframe src=\"https://www.herokucdn.com/error-pages/application-error.html\"></iframe>\\n  </body>\\n</html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.10/json/decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\n    @allure.epic('Getting booking')\n    @allure.feature('Positive')\n    @allure.story(\"Get bookings by name\")\n    def test_get_bookings_with_filter_name():\n    \n        # 1) Creating 5 bookings with correct payload\n        # 2) Getting parametres from booking for search\n        # 3) Getting booking by parametres\n        # 4) Asserting json is not empty\n        # 5) Asserting status code is 200\n        # 6) Asserting values in json\n        # 7) Deleting bookings by id\n    \n        list_bookings = []\n        for i in range(5):\n>           response = APIClient().create_booking(payload)\n\ntests/test_get_bookings.py:88: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nservices/api.py:96: in create_booking\n    self.attach_response_json(response.json())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Response [503]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.10/site-packages/requests/models.py:978: JSONDecodeError","flaky":false,"newFailed":false,"newBroken":true,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"_session_faker","time":{"start":1748888351754,"stop":1748888351755,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"testStage":{"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)","statusTrace":"self = <Response [503]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n\n../local/lib/python3.10/site-packages/requests/models.py:974: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../local/lib/python3.10/json/__init__.py:346: in loads\n    return _default_decoder.decode(s)\n../local/lib/python3.10/json/decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x7f0884d15c60>\ns = '<!DOCTYPE html>\\n<html>\\n  <head>\\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n    <met...  <body>\\n    <iframe src=\"https://www.herokucdn.com/error-pages/application-error.html\"></iframe>\\n  </body>\\n</html>'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.10/json/decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\n    @allure.epic('Getting booking')\n    @allure.feature('Positive')\n    @allure.story(\"Get bookings by name\")\n    def test_get_bookings_with_filter_name():\n    \n        # 1) Creating 5 bookings with correct payload\n        # 2) Getting parametres from booking for search\n        # 3) Getting booking by parametres\n        # 4) Asserting json is not empty\n        # 5) Asserting status code is 200\n        # 6) Asserting values in json\n        # 7) Deleting bookings by id\n    \n        list_bookings = []\n        for i in range(5):\n>           response = APIClient().create_booking(payload)\n\ntests/test_get_bookings.py:88: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nservices/api.py:96: in create_booking\n    self.attach_response_json(response.json())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Response [503]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n../local/lib/python3.10/site-packages/requests/models.py:978: JSONDecodeError","steps":[{"name":"Create a new booking in the API","time":{"start":1748888445470,"stop":1748888450511,"duration":5041},"status":"broken","statusMessage":"requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n","statusTrace":"  File \"/usr/workspace/services/api.py\", line 96, in create_booking\n    self.attach_response_json(response.json())\n  File \"/usr/local/lib/python3.10/site-packages/requests/models.py\", line 978, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":0,"hasContent":true,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"stepsCount":1,"attachmentsCount":0,"hasContent":true,"attachmentStep":false},"afterStages":[],"labels":[{"name":"story","value":"Get bookings by name"},{"name":"epic","value":"Getting booking"},{"name":"feature","value":"Positive"},{"name":"parentSuite","value":"tests"},{"name":"suite","value":"test_get_bookings"},{"name":"host","value":"f89c31e61e06"},{"name":"thread","value":"1-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_get_bookings"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"history":{"statistic":{"failed":0,"broken":1,"skipped":0,"passed":68,"unknown":0,"total":69},"items":[{"uid":"797edd29d39705d2","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/97//#testresult/797edd29d39705d2","status":"passed","time":{"start":1748801838216,"stop":1748801838656,"duration":440}},{"uid":"3559cb82e3aab15e","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/96//#testresult/3559cb82e3aab15e","status":"passed","time":{"start":1748715453804,"stop":1748715455977,"duration":2173}},{"uid":"748f2cae72f2619c","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/95//#testresult/748f2cae72f2619c","status":"passed","time":{"start":1748629122813,"stop":1748629123265,"duration":452}},{"uid":"2262f15fc18115c","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/94//#testresult/2262f15fc18115c","status":"passed","time":{"start":1748542729473,"stop":1748542730548,"duration":1075}},{"uid":"a124ae7b0ed77413","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/93//#testresult/a124ae7b0ed77413","status":"passed","time":{"start":1748456269631,"stop":1748456270684,"duration":1053}},{"uid":"b3fae78fc7a38ea3","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/92//#testresult/b3fae78fc7a38ea3","status":"passed","time":{"start":1748369875222,"stop":1748369875650,"duration":428}},{"uid":"6cc2bc5f44e529d2","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/91//#testresult/6cc2bc5f44e529d2","status":"passed","time":{"start":1748283479532,"stop":1748283480158,"duration":626}},{"uid":"4e2516c94620df89","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/90//#testresult/4e2516c94620df89","status":"passed","time":{"start":1748197004783,"stop":1748197005231,"duration":448}},{"uid":"f8e6dd7ee0fadd02","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/89//#testresult/f8e6dd7ee0fadd02","status":"passed","time":{"start":1748110598931,"stop":1748110599372,"duration":441}},{"uid":"62f256a678ad93c4","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/88//#testresult/62f256a678ad93c4","status":"passed","time":{"start":1748024262168,"stop":1748024263189,"duration":1021}},{"uid":"30ab7a8f3f35ad3b","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/87//#testresult/30ab7a8f3f35ad3b","status":"passed","time":{"start":1747937935914,"stop":1747937936353,"duration":439}},{"uid":"74cc9fdf9b417e68","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/86//#testresult/74cc9fdf9b417e68","status":"passed","time":{"start":1747851555504,"stop":1747851556060,"duration":556}},{"uid":"9eb88d66997a49e9","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/85//#testresult/9eb88d66997a49e9","status":"passed","time":{"start":1747765150904,"stop":1747765151945,"duration":1041}},{"uid":"f35b252684d48675","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/84//#testresult/f35b252684d48675","status":"passed","time":{"start":1747678737408,"stop":1747678737896,"duration":488}},{"uid":"3b510af79791f649","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/83//#testresult/3b510af79791f649","status":"passed","time":{"start":1747592222637,"stop":1747592223116,"duration":479}},{"uid":"e8e5156488ba493f","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/82//#testresult/e8e5156488ba493f","status":"passed","time":{"start":1747505819325,"stop":1747505820401,"duration":1076}},{"uid":"722ee2aa10b89b64","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/81//#testresult/722ee2aa10b89b64","status":"passed","time":{"start":1747419511931,"stop":1747419512224,"duration":293}},{"uid":"2394d894685e1c09","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/80//#testresult/2394d894685e1c09","status":"passed","time":{"start":1747333160100,"stop":1747333162315,"duration":2215}},{"uid":"ae67b8bb3b28bb3","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/79//#testresult/ae67b8bb3b28bb3","status":"passed","time":{"start":1747246652690,"stop":1747246656223,"duration":3533}},{"uid":"755772ab6a651935","reportUrl":"https://elenkaFila.github.io/pytest_api_testing/78//#testresult/755772ab6a651935","status":"passed","time":{"start":1747160376586,"stop":1747160379712,"duration":3126}}]},"tags":[]},"source":"10c5f68a1718af15.json","parameterValues":[]}